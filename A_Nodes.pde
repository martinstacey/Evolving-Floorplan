String hru [] = {"Ho 1|0.55|0(Pr 0|0.9|1(Zz 0|0.5|0,Pr 0|5.5|2(Bz 0|1.5|2(Bc 1|0.6|2(Be 0|3.5|0,Cl 1|1.5|0),Hz 1|0.45|0(Ba 0|5.5|0,Ha 1|4.5|0)),Mz 1|1.5|2(Mb 0|6|0,Ac 0|0.5|0(Ba 0|1.5|0,Wc 0|0.5|0)))),Pu 0|0.9|2(Pu 0|4.6|2(Lz 0|1.55|2(Li 1|2.5|0,Fo 0|4.5|2),Sz 0|1.6|2(Ki 0|7|0,Wa 0|7|0)),Zz 0|0.5|0))", "Ho 0|0.5|0(Pu 1|0.4|0(Se 0|0.5|0(Di 1|4|0,Ki 0|4.5|0),Li 0|4.5|0),Pr 1|0.55|0(Bz 1|1.5|2(Bc 0|0.6|1(Cl 1|2.5|0,Be 0|5.5|0),Hz 0|1.85|1(Ha 1|7|2,Ba 0|6.5|0)),Mz 0|1.5|2(Mb 0|0.5|0,Ac 1|0.5|0(Ba 0|6.5|0,Wc 0|7|0))))", "Ho 0|0.4|0(Pu 1|0.65|0(Li 2|4.5|0,Kz 0|1.7|2(Ki 0|0.5|0,Hz 1|1.65|2(Ha 1|4|0,Fo 0|5.5|0))),Pr 1|0.2|0(Zz 0|0.5|0,Pr 0|0.5|0(Bz 1|3|2(Bc 0|0.6|2(Be 0|5.5|0,Cl 1|7|0),Hz 1|1.5|2(Ha 1|6|0,Ac 0|0.5|0(Cl 0|0.5|0,Ba 0|0.5|0))),Mz 1|1.45|2(Mb 0|6.5|0,Ac 0|0.5|0(Ba 0|0.5|0,Wc 0|0.5|0)))))", "Ho 1|0.55|0(Pr 0|0.6|0(Bz 0|1.85|2(Bc 1|0.6|2(Be 0|3.5|0,Cl 1|0.5|0),Hz 1|1.8|2(Ba 1|0.5|0(Ba 0|2.5|0,Ba 0|6.5|0),Al 0|0.5|0(Ah 1|0.6|2(Ha 1|3|0,Wa 1|1|0),Ha 1|4.5|0))),Mc 1|0.6|2(Mb 0|6.5|0,Cl 1|1.5|0)),Pu 0|0.35|0(Ki 0|3.5|0,Li 0|2.5|0))", "Ho 0|0.5|0(Pr 1|0.5|0(Mc 0|0.6|2(Mb 0|4.5|0,Cl 1|7|0),Bz 0|1.7|2(Bc 1|0.6|1(Cl 1|4.5|0,Be 0|2.5|0),Hz 1|0.5|0(Ha 1|2.5|0,Ba 0|6|0))),Pu 0|0.4|0(Se 1|0.5|0(Ki 1|2.5|0,Az 1|0.5|0(Ha 1|2.5|0,Ah 1|0.5|0(Wc 0|0.5|0(Ha 0|0.5|0,Wa 0|0.5|0),Ba 0|0.5|0))),Li 0|0.5|0))", "Ho 0|0.5|0(Pu 1|0.35|0(Se 0|0.4|0(Wa 0|2.5|0,Ki 0|5.5|0),Li 0|4.5|0),Pr 1|0.35|0(Be 0|5.5|0,Mz 1|2.7|1(Hz 0|0.25|0(Ha 1|6.5|0,Ac 1|0.6|1(Cl 1|1.5|0,Ac 1|0.6|2(Ba 0|7|0,Cl 1|5.5|0))),Mb 0|0.5|0)))", "Ho 0|0.7|0(Pu 0|0.5|0(Bz 1|1|2(Bz 1|2.5|2(Mb 0|3.5|0,Ac 0|0.5|0(Ba 0|0.5|0,Wa 0|0.5|0)),Zz 0|0.5|0),Lz 1|0.65|0(Li 2|4.5|0,Kz 0|0.5|0(Ki 0|0.5|0,Fo 0|5.5|0))),Pr 1|0.65|0(Bz 1|0.65|2(Be 2|5.5|2,Cl 0|0.5|0(Bx 0|6|0,Cl 1|1.5|2)),Az 1|0.5|0(Ba 0|0.5|0,Ah 0|0.5|0(Ha 1|7|0,Ba 0|7|0))))", "Ho 0|0.3|0(Pr 1|0.5|0(Az 0|1.15|2(Ac 1|0.6|2(Ba 0|3.5|0,Cl 1|4.5|2),Cz 1|0.5|0(Cl 0|4.5|0,Ha 1|3.5|0)),Be 0|1.5|0),Pu 0|0.5|0(Lz 1|0.35|0(Kz 0|1.5|1(Hz 1|0.5|0(Wa 0|2.5|0,Ha 1|5.1|0),Ki 0|4.5|0),Li 0|5.5|0),Mz 1|0.55|0(Az 0|0.5|0(Hz 1|1.3|2(Cz 0|0.6|1(Cl 1|7|0,Wc 0|5.5|0),Ha 1|7|0),Ba 0|4.5|0),Mb 2|0.1|0)))", "Ho 0|0.4|0(Pu 0|1.5|2(Bz 1|0.4|0(Ac 0|0.5|0(Wc 0|4.5|0,Ba 0|5.5|0),Be 0|2.5|0),Fz 1|0.35|0(Wa 0|0.5|0,Fo 0|5.5|0)),Pr 1|0.6|0(Lz 0|0.35|0(Se 1|1.7|2(Ki 0|2.5|0,Ha 2|6.5|0),Li 2|6.5|2),Mz 0|2.4|1(Az 1|1.2|1(Lz 0|0.6|1(Cl 1|2.5|0,Ha 0|0.5|0),Ac 0|0.6|2(Ba 0|1.5|0,Cl 1|3|0)),Mb 2|7|0)))", "Ho 0|0.65|0(Pu 0|0.35|0(Bz 1|0.5|0(Be 0|3.5|0,Az 1|0.5|0(Cz 0|0.5|0(Wc 0|0.5|0,Ha 1|1|0),Ba 0|1.5|0)),Lz 1|0.6|0(Li 2|4.5|0,Se 0|0.65|0(Kz 0|0.5|0(Di 0|0.5|0,Ki 0|0.5|0),Fo 0|4.5|0))),Pr 1|0.6|0(Mz 0|1.8|2(Mb 0|6.5|0,Wc 0|6.5|0),Bz 0|0.5|0(Bz 0|0.5|0(Wa 0|1.5|0,Ba 0|0.5|0),Zz 0|0.5|0)))", "Ho 1|0.5|0(Pr 0|0.6|0(Mz 0|1.5|2(Mc 1|0.6|2(Mb 0|3.5|0,Cl 1|0.5|0),Ac 1|1.8|2(Ba 0|4.5|0,Ha 1|4.5|0)),Bc 1|0.6|2(Be 0|6.5|0,Cl 1|1.5|0)),Pu 0|0.6|0(Li 0|5.5|0,Se 1|1.5|1(Wa 0|5|0,Ki 0|6|0)))", "Ho 0|0.5|0(Pu 1|0.35|0(Se 0|0.4|0(Wa 0|2.5|0,Ki 0|5.5|0),Li 0|4.5|0),Pr 1|0.35|0(Be 0|5.5|0,Mz 1|2.7|1(Hz 0|0.25|0(Ha 1|6.5|0,Ac 1|0.6|1(Cl 1|1.5|0,Ac 1|0.6|2(Ba 0|7|0,Cl 1|5.5|0))),Mb 0|0.5|0)))", "Ho 0|0.5|0(Pr 1|0.6|0(Bz 1|2.5|2(Bc 0|0.6|2(Be 0|4.5|0,Cl 1|7|0),Hz 0|0.45|0(Ba 0|2.5|0,Hz 1|0.5|0(Ha 1|3.5|0,Cl 0|0.6|1(Cl 1|2.5|0,Cl 0|0.6|2(Ha 1|0.1|0,Wa 1|6|0))))),Mc 0|0.6|2(Mb 0|1.5|0,Cl 1|7|0)),Pu 1|0.3|0(Ki 0|4.5|0,Lz 1|0.85|0(Li 0|5.5|0,Zz 0|0.5|0)))", "Ho 0|0.7|0(Pu 0|0.5|0(Mz 1|0.45|0(Az 1|0.5|0(Ba 0|4.5|0,Cz 0|0.5|0(Wc 0|4.5|0,Ha 1|4.5|0)),Mb 0|2.5|0),Lz 1|0.45|0(Se 0|1.6|2(Ki 1|4.5|0,Fo 0|0.5|0),Li 2|1|0)),Pr 1|0.45|0(Az 1|0.5|0(Ba 0|5.5|0,Hz 0|1.2|1(Ha 1|6.5|0,Wc 0|0.5|0)),Be 0|0.5|0))", "Ho 0|0.3|0(Pr 1|0.4|0(Wz 0|0.5|0(Wc 0|4.5|0,Ba 0|5.5|0),Mb 0|2.5|0),Pu 0|0.55|0(Lz 1|0.4|0(Kz 0|0.5|0(Ki 1|5.5|0,Fo 0|0.5|0),Li 2|1.5|0),Bz 1|0.4|0(Az 0|0.5|0(Ba 0|4.5|0,Wc 0|5.5|0),Be 0|7|0)))", "Ho 0|0.5|0(Pu 0|0.5|0(Mz 0|0.7|0(Mb 2|2|0,Cz 1|0.7|0(Hz 1|0.5|0(Ha 0|2.5|0,Wc 0|7|0),Ba 0|7|0)),Cz 2|3.4|1(Ki 1|7|0,Li 0|5.5|0)),Pr 0|0.5|0(Bz 0|0.25|0(Hz 1|0.3|0(Ha 1|7|0,Ac 1|0.5|0(Wc 0|0.5|0,Ba 0|6|0)),Be 0|0.5|0)))", "Ho 0|0.7|0(Pu 0|0.5|0(Mz 1|0.25|0(Sz 0|0.4|0(Zz 0|0.5|0,Wa 0|3.5|0),Mc 0|0.3|0(Ac 1|0.55|0(Ba 0|3.5|0,Wc 0|2.5|0),Mb 0|2.5|0)),Lz 1|0.4|0(Kz 0|0.5|0(Fo 0|0.5|0,Ki 1|4.5|0),Li 2|0.5|0)),Pr 1|0.5|0(Az 1|0.5|0(Ba 0|0.5|0,Cl 0|0.5|0(Ha 0|0.5|0,Wc 0|5|0)),Be 0|0.5|0))", "Ho 0|0.65|0(Pu 0|0.5|0(Mz 1|0.65|0(Mb 0|3.5|0,Ac 0|0.5|0(Ba 0|0.5|0,Wa 0|0.5|0)),Lz 1|0.65|0(Li 2|4.5|0,Kz 0|0.5|0(Ki 0|0.5|0,Fo 0|5.5|0))),Pr 1|0.65|0(Bz 1|0.8|0(Be 2|5.5|0,Cl 0|1.45|1(Bx 0|6.5|0,Cl 1|1.5|0)),Hz 1|0.6|0(Ba 0|0.5|0,Ah 0|0.5|0(Ha 1|6|0,Ba 0|7|0))))", "Ho 0|0.5|0(Pu 1|0.5|0(Sz 1|2|1(Zz 0|4|0,Se 0|0.5|0(Wa 0|3|0,Ki 0|4|0)),Li 0|4|0),Pr 1|0.5|0(Mc 0|0.6|1(Cl 1|2|0,Mb 0|5|0),Bz 1|1.5|1(Ah 0|1.8|1(Ha 1|6|0,Ba 0|6|0),Bc 0|0.6|1(Cl 1|2|0,Be 0|0.1|0))))", "Ho 1|0.5|0 (Pr 0|0.5|0(Mb 0|3,Bz 1|1.5|2(Bc 0|0.6|1(Cc 1|0.5|0(Cl 1|2,Cl 1|6),Be 0|5),Ah 0|1.8|1(Ha 1|5,Ba 0|7))),Pu 0|3.2|2(Li 0|5,Se 1|2|2(Ki 0|6,Wa 0|1)))", "Ho 0|6|2(Pu 1|0.5|0(Se 0|2|1(Wa 0|3|0,Ki 0|4|0),Li 0|4|0),Pr 1|0.5|0(Mz 0|1.5|1(Ac 1|0.5|0(Ba 0|3|0,Wc 0|2|0),Mb 0|5|0),Bz 0|2.6|1(Hz 1|1.2|1(Ha 0|6|0,Ca 0|0.6|2(Ba 0|0.1|0,Cl 1|2|0)),Be 0|7|0)))", "Ho 0|0.45|0(Pu 1|3.5|1(Se 0|0.4|0(Wa 0|3|0,Ki 0|4|0),Li 0|4|0),Pr 1|5.4|1(Bz 0|1.8|1(Ah 1|1.85|2(Ba 0|5|0,Ha 1|6|0),Bc 1|0.6|2(Be 0|6|0,Cl 1|0.1|0)),Mz 0|0.6|1(Cl 1|2|0,Mb 0|0.1|0)))", "Ho 0|0.5|0 (Pu 1|0.5|0(Se 1|1.8|1(Wa 0|5.1,Kz 0|1.5|2(Ki 0|4 ,Ah 1|1.5|2(Ba 0|4.1,Ha 1|4.1))),Li 0|4.1),Pr 1|0.5|0(Bz 1|1.5|2(Be 0|5.1,Hz 0|0.5|0(Ha 1|7,Cl 0|0.1)),Mz 1|0.6|1(Cl 1|4.1,Mb 0|7)))", "Ho 0|0.5|0(Pu 1|0.5|0(Se 1|0.5|0(Ki 0|4.5|0,Wa 0|4.5|0),Li 0|4.5|0),Pr 1|0.65|0(Bz 1|1.55|2(Bc 0|0.6|1(Cl 1|2.5|0,Be 0|5.5|0),Ah 0|0.5|0(Ha 2|6.5|2,Ba 0|6.5|0)),Mc 0|0.6|1(Cl 1|3.5|0,Mb 0|0.5|0)))", "Ho 0|0.5|0(Pu 1|0.55|0(Li 2|5|2,Sz 0|0.35|0(Fo 0|5|0,Se 1|0.7|0(Ki 0|1.1|0,Wa 0|0.1|0))),Pr 1|0.55|0(Bz 1|1.5|2(Bc 0|0.6|1(Cl 1|2.1|0,Be 0|5.1|0),Ah 0|0.5|0(Ha 1|6.1|0,Ba 0|0.1|0)),Mc 0|0.6|1(Cl 1|3|0,Mb 0|0.1|0)))", "Ho 0|0.55|0(Pu 0|3.05|2(Li 0|4.1|0,Sz 1|0.5|0(Se 1|1.5|2(Ki 0|6.1|0,Ha 1|6.1|0),Ah 1|0.5|0(Cl 0|3.1|0,Ba 0|0.1|0))),Pr 1|0.5|0(Bz 0|1.5|1(Al 1|1.5|2(Ba 0|5.1|0,Ha 1|7|0),Bc 1|0.6|1(Cl 1|4.1|0,Be 0|6.1|0)),Mb 0|0.1|0))", "Ho 1|0.65|0(Pr 1|0.5|0(Mz 0|0.35|0(Ac 1|0.5|0(Ba 0|3.5|0,Cl 0|2.5|0),Be 0|5.5|0),Bz 0|0.5|0(Ah 0|0.7|0(Ba 0|0.5|2,Ha 1|4.5|0),Be 0|7|0)),Pu 0|0.35|0(Kz 1|0.8|2(Ki 1|2.5|0,Cl 1|1.5|0),Li 0|5.5|0))", "Ho 0|0.4|0(Pu 1|0.6|0(Li 2|4.5|0,Sz 0|0.5|0(Ki 1|0.5|0,Ha 0|4.5|0)),Pr 1|0.6|0(Hz 1|1.8|2(Ah 0|2|1(Ba 0|5|0,Be 0|5.5|1),Bz 0|0.5|0(Ha 1|7|0,Ah 0|0.5|0(Ha 1|6.5|0,Cc 1|0.5|0(Cl 0|0.5|0,Cl 0|0.5|0)))),Mz 0|0.5|0(Cc 0|0.5|0(Wa 0|0.5|2,Ba 0|3.5|0),Mb 0|0.5|0)))", "Ho 0|0.45|0(Pu 1|0.5|0(Li 2|4.1|0,Se 0|2|2(Ki 1|0.1|0,Ha 0|5|2)),Pr 0|0.5|0(Bz 1|0.5|0(Bc 0|0.65|2(Be 0|5.1|1,Cl 1|6.1|1),Hz 1|1.8|1(Ha 1|6.1|0,Ca 0|0.5|0(Wa1|5|0,Ba 0|1.1|0))),Mz 1|0.65|0(Mb 0|6.1|0,Ac 0|0.5|0(Ba 0|1.1|0,Cl 0|0.1|0))))", "Ho 0|0.5|0(Pu 1|0.45|0(Se 0|0.65|0(Ki 2|3.5|0,Sz 1|0.5|0(Wa 0|6.5|0,Cl 0|0.6|2(Ha 1|4.5|0,Cl 1|6.5|0))),Li 0|4.5|0),Pr 1|0.65|0(Bz 0|2|1(Ah 1|2.7|2(Ba 0|5.5|0,Ha 2|6.5|0),Be 0|6|0),Mc 0|0.6|1(Mb 1|3|0,Cl 0|0.5|0)))", "Ho 0|0.5|0(Pr 1|0.55|0(Hz 0|0.7|0(Ba 0|3.5|0,Ah 1|1.8|2(Ba 0|4.5|0,Ha 1|3.5|0)),Bz 0|0.5|0(Mc 1|0.6|1(Cl 1|4.5|0,Mb 0|2.5|0),Bc 1|0.65|1(Cl 1|4.5|0,Be 0|2.5|0))),Pu 1|0.35|0(Kz 0|0.5|0(Ki 0|3.5|0,Di 1|4.5|0),Li 0|5.5|0))", "Ho 1|0.5|0(Pri 0|0.5|0(Bz 0|0.7|0(Bc 1|0.6|2(Be 0|3.5|0,Cl 1|1.5|0),Hz 1|0.5|0(Ba 1|0.5|0(Ba 0|2.5|0,Ba 0|5.5|0),Al 0|0.5|0(Ha 1|5.5|0,Ah 1|0.65|2(Ha 1|6|0,Wa 1|0.5|0)))),Mc 1|0.8|2(Mb 0|6.5|0,Cl 1|1|0)),Pu 0|0.35|0(Ki 0|3|0,Li 0|2.5|0))", "Ho 0|0.5|0(Pr 0|0.6|0(Li 0|0.5|0,Se 1|0.55|0(Ki 1|6.5|0,Sz 1|1.5|1(Ha 1|6.5|0,Wa 0|0.5|0))),Pu 1|0.55|0(Mz 0|0.3|0(Hz 1|0.5|0(Ba 0|3.5|0,Wc 0|2.5|0),Mb 0|5.5|0),Bz 0|0.5|0(Hz 1|1.5|1(Ha 1|6|0,Ba 0|0.5|0),Be 0|7|0)))", "Ho 0|0.7|0(Pu 0|0.5|0(Bz 1|0.7|0(Ba 0|3.5|0,Hc 0|0.5|0(Cl 0|0.5|0,Ha 0|0.5|0)),Lz 1|1|2(Lz 1|0.35|0(Se 0|0.5|0(Wa 0|4.5|0,Ki 0|5.5|0),Li 0|4.5|0),Zz 0|0.5|0)),Pr 1|0.5|0(Hz 1|0.65|0(Ba 0|5.5|0,Hc 0|0.5|0(Ha 1|6|0,Cl 0|0.5|0)),Be 0|0.5|0))", "Ho 0|0.7|0(Pu 0|0.5|0(Bz 3|0.4|0(Ba 0|2|0,Hc 0|0.5|0(Cl 0|4.5|0,Ha 0|5.5|0)),Lz 1|0.8|2(Lz 1|0.4|0(Se 0|0.5|0(Wa 0|4.5|0,Ki 0|1|0),Li 2|1.5|0),Zz 0|0.5|0)),Pr 1|0.35|0(Hz 1|1.75|2(Ba 0|5.5|0,Hc 0|0.5|0(Ha 1|7|0,Cl 0|4.5|0)),Be 0|0.5|0))", "Ho 0|0.4|0(Pu 1|0.5|0(Se 3|0.5|0(Ki 0|5.5|0,Wa 0|5|0),Li 0|4.5|0),Pr 1|0.5|0(Bz 0|1.8|1(Ba 0|4.5|0,Bc 0|0.6|1(Cl 1|2.5|0,Be 0|5.5|0)),Mb 0|0.5|0(Hz 1|1.3|1(Ha 1|6.5|0,Ac 1|0.5|0(Wc 0|2.5|0,Ba 0|2.5|0)),Mb 0|7|0)))", "Ho 0|0.5|0(Pu 1|0.4|0(Se 0|0.5|0(Di 1|4|0,Ki 0|4.5|0),Li 0|4.5|0),Pr 1|0.55|0(Bz 1|1.5|2(Bc 0|0.6|1(Cl 1|2.5|0,Be 0|5.5|0),Hz 0|1.85|1(Ha 1|7|2,Ba 0|6.5|0)),Mz 0|1.5|2(Mb 0|0.5|0,Ac 1|0.5|0(Ba 0|6.5|0,Wc 0|7|0))))", "Ho 1|0.5|0(Pr 0|1|1(Zz 0|0.5|0,Pr 0|0.5|0(Bz 0|1.5|2(Be 0|3.5|0,Bh 1|2|2(Ba 0|4.5|0,Ha 1|4.5|0)),Mz 0|1.5|1(Hz 1|0.4|0(Ba 0|2.5|0,Hc 1|0.5|0(Cl 0|2.5|0,Ha 1|6.5|0)),Mb 0|6.5|0))),Pu 0|1|2(Pu 0|0.5|0(Li 0|5|0,Kz 0|0.5|0(Di 1|6.5|0,Ki 0|6.5|0)),Zz 0|0.5|0))", "x 0|0.5|0(a 0|0.5|0,x(b 0|0.5|0,c 0|0.5|0))", "x 0|0.5|0(Be 0|0.5|0,Ba 0|0.5|0)", };          
String hnames [][] = {{"Do", "door"}, {"Fo", "Foyer"}, {"Ha", "Hall"}, {"Tv", "Tv Room"}, {"Li", "Living"}, {"Di", "Dining"}, {"Ki", "Kitchen"}, {"Wa", "Washing"}, {"Mb", "Master Bedroom"}, {"Be", "Bedroom"}, {"Cl", "Closet"}, {"Wc", "Waking Cl"}, {"Ba", "Bathroom"}, {"Bx", "Bed Extension"}, {"a", "a"}, {"b", "b"}, {"c", "c"}, {"Ex", "Extra"}, };      
String hdim[] = {"12.5x9", "9x9.6", "12.2x9", "9x9.5", "11x7", "7x9", "12x9", "12x7", "12x7.5", "15x7", "8.5x9.5", "10x12", "8.1x9.5", "11x8", "12.75x7", "20x5", "12x6.5", "12x10", "12x10", "10x10", "12x8", "12x10", "10x10", "10x10", "10x10", "12x8", "8x12", "12x8", "12x8", "12x10", "12x8", "12x10", "12x8", "12x10", "12x10", "12x10", "10x12", "12x12", "10x10", "10x10", };          
String hr1[][] = {{"Ba","1.75","2.85","5.08","0.63","Ha,Mb,Be"},{"Be","3.09","3.8","12.11","0.83","Ha,Cl,Ba"},{"Bx","0.79","1.58","1.7","0.62","Cl,Ba,Ha"},{"Cl","0.73","2.51","1.83","0.34","Mb,Ha,Be"},{"Di","3.17","3.9","12.55","0.81","Ki,Li,Ha"},{"Fo","1.59","3.2","5.24","0.51","Li,Ki,Ha"},{"Ha","1.25","3.17","4.08","0.49","Ba,Li,Be"},{"Ki","2.43","3.6","9","0.7","Li,Ba,Ha"},{"Li","4.03","6.37","26.8","0.67","Ki,Ha,Mb"},{"Mb","3.4","4.19","14.49","0.82","Cl,Ha,Ba"},{"Tv","3.3","4.45","14.08","0.71","Li,Mb,Be"},{"Wa","2.08","2.85","5.76","0.71","Ki,Li,Ba"},{"Wc","2.12","2.87","5.53","0.69","Ba,Mb,Ha"},{"a","0","0","0","0",",,"},{"b","0","0","0","0",",,"},{"c","0","0","0","0",",,"},{"Ex","0","0","0","0",",,"},};      
String hr2[][] = {{"Ba","0.36","0.7","0.84","0.84","0.62,0.42,0.36"},{"Be","0.58","0.63","0.64","0.64","0.6,0.55,0.43"},{"Bx","0.31","0.57","0.84","0.84","0.8,0.73,0.65"},{"Cl","0.1","0.46","0.92","0.92","0.54,0.52,0.49"},{"Di","0.69","0.68","0.62","0.62","0.86,0.83,0.57"},{"Fo","0.61","0.52","0.69","0.69","0.89,0.74,0.48"},{"Ha","0.34","0","0.73","0.73","0.72,0.64,0.53"},{"Ki","0.54","0.61","0.7","0.7","0.73,0.43,0.42"},{"Li","0.9","0.14","0","0","0.73,0.65,0.43"},{"Mb","0.5","0.56","0.59","0.59","0.62,0.55,0.53"},{"Tv","0.64","0.69","0.67","0.67","1,0.86,0.57"},{"Wa","0.6","0.5","0.65","0.65","0.97,0.25,0.19"},{"Wc","0.35","0.51","0.78","0.78","0.83,0.56,0.5"},{"a","0","0","0","0","0,0,0"},{"b","0","0","0","0","0,0,0"},{"c","0","0","0","0","0,0,0"},{"Ex","0","0","0","0","0,0,0"},};      

//ojo falta total area

String nodeText = "";
String nodeText2 = "";

ArrayList <Node> thenlist;
PVector nlistpos = new PVector (1100, 100);
PVector nlistsize = new PVector (500, 80);
float   nlistscale = 40;
PVector houseSize = new PVector (10, 9);

ArrayList <Node> thenlist2;
PVector          nlistpos2 = new PVector (1100, 450);
PVector          nlistsize2 = new PVector (500, 80);
float            nlistscale2 = 40;
PVector          houseSize2 = new PVector (10, 9);

void setupno() {
  thenlist = new ArrayList <Node>();
  thenlist = setupnodehouse(setupnodetree(Nodesfromstring(hru[ButtonSl [0]]), nlistpos, nlistsize), houseSize);

  thenlist2 = new ArrayList <Node>();
  thenlist2 = setupnodehouse(setupnodetree(Nodesfromstring(hru[ButtonSl [1]]), nlistpos2, nlistsize2), houseSize2);
}
void drawno() {
  if (thenlist.size()>0) for (int i=0; i<thenlist.size(); i++) thenlist.get(i).display();
  if (!bState[0]) thenlist=setupnodehouse(thenlist, houseSize);

  houseSize2 = dimension(hdim[ButtonSl[1]]);
  //if (thenlist2.size()>0) for (int i=0; i<thenlist2.size(); i++) thenlist2.get(i).display();
  if (!bState[0]) thenlist2=setupnodehouse(thenlist2, houseSize2);
}
void pressno() {
  if (thenlist.size()>0) for (int i=0; i<thenlist.size(); i++) thenlist.get(i).fatherselect();
  if (thenlist.size()>0) for (int i=0; i<thenlist.size(); i++) thenlist.get(i).branchselect(thenlist);
  if (thenlist.size()>0) for (int i=0; i<thenlist.size(); i++) thenlist.get(i).atrselect();

  if (thenlist2.size()>0) for (int i=0; i<thenlist2.size(); i++) thenlist2.get(i).fatherselect();  
  if (thenlist2.size()>0) for (int i=0; i<thenlist2.size(); i++) thenlist2.get(i).branchselect(thenlist2);
  if (thenlist2.size()>0) for (int i=0; i<thenlist2.size(); i++) thenlist2.get(i).atrselect();
}
void scrollno(boolean updown) {
  if (thenlist.size()>0) for (int i=0; i<thenlist.size(); i++) thenlist.get(i).scroll(updown);
  if (thenlist2.size()>0) for (int i=0; i<thenlist2.size(); i++) thenlist2.get(i).scroll(updown);
}

void swapselnodes() {
  thenlist = swapno(thenlist, thenlist2);
  for (int i = 0; i< thenlist.size(); i++) thenlist.get(i).fatherselect = false;
  for (int i = 0; i< thenlist.size(); i++) thenlist.get(i).select = false;
  for (int i = 0; i< thenlist2.size(); i++) thenlist2.get(i).fatherselect = false;
  for (int i = 0; i< thenlist2.size(); i++) thenlist2.get(i).select = false;
}
void randomswap() {
  thenlist = randomsw(thenlist, thenlist2);
  for (int i = 0; i< thenlist.size(); i++) thenlist.get(i).fatherselect = false;
  for (int i = 0; i< thenlist.size(); i++) thenlist.get(i).select = false;
  for (int i = 0; i< thenlist2.size(); i++) thenlist2.get(i).fatherselect = false;
  for (int i = 0; i< thenlist2.size(); i++) thenlist2.get(i).select = false;
}
void selectinternal() {
  thenlist = selectinternal(thenlist);
}
void swap() {
  thenlist = sawpinternal(thenlist);
}
class Node implements Comparable {
  String code, name, atributes, loc;
  int gen, ngen, nrooms, nleafs, nroots, num, leafnum;
  PVector pos, gpos, gsize, tpos, tsize;
  boolean select, mselect, fatherselect, motherselect, childA, room, leaf;
  Node childa, childb, father;
  ArrayList <Node>  adjacent, tadjacent, conect;
  float clr;
  String [] atr; 
  float nodeSize = 20;
  float atrsize  = 20;
  ArrayList <Atrib>  atri;
  FloatList  idealqualities = new FloatList();
  FloatList       qualities = new FloatList();
  FloatList qualitiesweight = new FloatList();
  ArrayList <String> idealadjacent;
  ArrayList <String>  idealadjw; 
  float fitadj, fit, totalfit;


  Node (String _code, String _atributes, String _loc) {
    code=_code;
    for (int i=0; i<hnames.length; i++)   if (code.equals(hnames[i][0]))   name=hnames[i][1];
    for (int i=0; i<hr1.length; i++) if (code.equals(hr1[i][0])) for (int j=1; j<hr1[i].length-1; j++) idealqualities.append(float(hr1[i][j]));     //No incluye ideal adj es otro lista float list
    for (int i=0; i<hr1.length; i++) if (code.equals(hr1[i][0])) for (int j=1; j<hr1[i].length-1; j++) qualitiesweight.append(float(hr2[i][j]));    
    for (int i=0; i<hr1.length; i++) if (code.equals(hr1[i][0])) idealadjacent  = new ArrayList<String>(Arrays.asList(split(hr1[i][5], ',')));
    for (int i=0; i<hr2.length; i++) if (code.equals(hr2[i][0])) idealadjw= new ArrayList<String>(Arrays.asList(split(hr2[i][5], ',')));
    loc=_loc;
    gen = _loc.length(); 
    adjacent = new ArrayList<Node> ();
    conect   = new ArrayList<Node> ();
    select=fatherselect=childA=room=false;
    atributes=_atributes;
    atr = split(atributes, '|');
    atri = new ArrayList<Atrib> ();
    atri.add(0, new Atrib ( 0, 0, 1, 3, atrsize));
    atri.add(1, new Atrib ( 0.5, 0, 0.01, 10.0, atrsize));
    atri.add(2, new Atrib ( 0, 0, 1, 2, atrsize));
    for (int i=0; i <atr.length; i++) {
      if (!(atr[0].equals(null)||atr[0].equals(""))) if (i==0) atri.set(0, new Atrib ( float(atr[0]), 0, 1, 3, atrsize));
      if (i==1) atri.set(1, new Atrib ( float(atr[1]), 0.1, 0.01, 10.0, atrsize));
      if (i==2) atri.set(2, new Atrib ( float(atr[2]), 0, 1, 2, atrsize));
    }
  }
  int compareTo (Object objI) {                                        
    Node iToCompare = (Node) objI;
    if (loc.compareTo(iToCompare.loc)<0) return -1;                              
    else if (loc.compareTo(iToCompare.loc)>0) return 1;       
    return 0;
  }
  void display() {   
    if (pos!=null) {
      if (childa!=null)   line(pos.x, pos.y+(nodeSize*.5), childa.pos.x, childa.pos.y-(nodeSize*.5));
      if (childb!=null)   line(pos.x, pos.y+(nodeSize*.5), childb.pos.x, childb.pos.y-(nodeSize*.5));
      stroke(200);
      colorMode(HSB, 1.0, 1.0, 1.0, 1.0);
      if (select) fill(clr, 1, 1, 1);        
      else fill(clr, 1, 1, 0.1);    
      if (mselect) fill(.5+clr*.5);
      rectMode(CENTER);
      rect(pos.x, pos.y, nodeSize, nodeSize, nodeSize*.25);  
      colorMode(RGB, 255, 255, 255);
      fill(0);
      textAlign(CENTER, CENTER);
      textSize(10);
      text (code, pos.x, pos.y);
      textSize(10);

      if (fatherselect||motherselect)  if (atri.size()>1) for (int i=0; i <atri.size(); i++) atri.get(i).display();    
      //if (atri.size()>1) for (int i=0; i <atri.size(); i++) atri.get(i).display();
      //if (!fatherselect) if (atri.size()>1) for (int i=0; i <atri.size(); i++) atri.get(i).select=false;
      StringBuffer atcomp = new StringBuffer();
      //if (idealqualities.size()!=0) for (int i=0; i<idealqualities.size(); i++) if (idealqualities.get(i)!=0)                  text(nf(idealqualities.get(i), 0, 0), pos.x+i*15, pos.y-15);
      //if (gsize!=null) text("x"+nf(gsize.x,0,0)+"y"+nf(gsize.y,0,0), pos.x, pos.y-15);
      //text(leafnum, pos.x, pos.y-15);
      for (int i=0; i<atri.size(); i++) if (atri.size()>1) {
        if (i==0)  atcomp.append(nf(atri.get(i).value, 0, 0));
        else   atcomp.append('|' + nf(atri.get(i).value, 0, 0));
      }
      atributes = atcomp.toString();
    }
  }
  void atrselect() {
    if (atri.size()>1) for (int i=0; i<atri.size(); i++)  atri.get(i).select();
  }
  void scroll (boolean updown) {
    for (int i=0; i <atri.size(); i++) atri.get(i).scroll(updown);
  }
  boolean isover() {
    if (mouseX>pos.x-(nodeSize*.5)&&mouseX<pos.x+(nodeSize*.5)&&mouseY>pos.y-(nodeSize*.5)&&mouseY<pos.y+(nodeSize*.5)) return true; 
    else return false;
  }
  void fatherselect() {
    if (isover()) fatherselect=!fatherselect;
  }
  void branchselect (ArrayList <Node> nl) {
    for (int i=0; i<nl.size(); i++) if (nl.get(i).isover()) if (nl.get(i).loc.length()<=loc.length()) if (loc.substring(0, nl.get(i).loc.length()).contains(nl.get(i).loc)) select = !select;
  }
}
class Atrib {
  float value, step, min, max;
  PVector  pos;
  boolean select=false;
  PVector size;
  Atrib(float _value, float _min, float _step, float _max, float _size) {
    value=_value;
    step=_step;
    min=_min;
    max=_max;
    size=new PVector (_size, _size);
  }
  void display() {
    if (select) fill(200);
    else fill(255);
    rect(pos.x, pos.y, size.x, size.y, size.y*.25);
    fill(0);
    text(nf(value, 0, 0), pos.x, pos.y);
  }
  void select() {
    if (mouseX>pos.x-(size.x*.5)&&mouseX<pos.x+(size.x*.5)&&mouseY>pos.y-(size.y*.5)&&mouseY<pos.y+(size.y*.5)) select = !select;
  }
  void scroll(boolean updown) {
    if (select&&!updown&&value<max) value = value + step;
    if (select&&updown&&value>min) value = value - step;
    if (value<min) value=min;
    if (value>max) value=max;
  }
}
StringList typology (ArrayList <Node> a) {
  StringList t = new StringList();
  for (int i=0; i<a.size(); i++) if (a.get(i).room) t.append(a.get(i).name);
  t.sort();
  for (int i=0; i<t.size()-1; i++) {
    if (t.get(i).equals(t.get(i+1))) t.set(i, "2)"+t.get(i));
    if (t.get(i).equals(t.get(i+1))) t.remove(i+1);
    else t.set(i, "1)"+t.get(i));
  }
  return t;
}
PVector dimension (String stdim) {
  String stsel[]  = split(stdim, 'x');
  PVector dsel;
  if (stsel.length!=2) dsel = new PVector(0, 0); 
  else dsel = new PVector (float(stsel[0]), float (stsel[1]));
  return dsel;
}

ArrayList <Node> Nodesfromstring(String d) {                                                                   // NODE CREATION: Code, Atributes, Loc
  ArrayList <Node> temParents   = new ArrayList <Node>();
  ArrayList <Node> nodeList     = new ArrayList <Node>();
  Node current=null;
  Node parent =null;
  Node root=null;
  boolean right=false;
  String code="";
  String atrbs="";

  for (int i=0; i<d.length(); i++) {  
    if (Character.isLetter(d.charAt(i))) code=code+d.charAt(i);
    if (Character.isDigit(d.charAt(i))||d.charAt(i)=='|'||d.charAt(i)=='.') atrbs= atrbs+d.charAt(i);
    if (d.charAt(i)=='(') if (code!="") {        
      if (root==null) { 
        Node newNode = new Node(code, atrbs, "0");
        root = newNode;
        current=newNode;
        temParents.add(current);
        nodeList.add(current);
        code="";
        atrbs="";
      } else if (root!=null &&!right) { 
        Node newNode = new Node(code, atrbs, current.loc + '0');  
        parent = current;
        current = current.childa;
        if (current==null) {
          current=newNode;
          temParents.add(current);
        }
        nodeList.add(current);
        code="";
        atrbs="";
      } else if (root!=null &&right) { 
        Node newNode = new Node(code, atrbs, current.loc + '1');
        parent = current;
        current = current.childb;
        if (current==null) {
          current=newNode;
          temParents.add(current);
        }
        nodeList.add(current);
        right=false;
        code="";
        atrbs="";
      }
    }
    if (d.charAt(i)==',') {
      right=true;
      if (code!="") { 
        Node newNode = new Node(code, atrbs, current.loc + '0');  
        parent = current;
        current = current.childa;
        if (current==null) {
          current=newNode;
          temParents.add(current);
        }
        nodeList.add(current);
        code="";
        atrbs="";
      }
      if (d.charAt(i-1)!='(') {        
        if (!temParents.isEmpty()) temParents.remove(temParents.size()-1);
        if (!temParents.isEmpty()) current = temParents.get(temParents.size()-1);
        if (!temParents.isEmpty()) temParents.remove(temParents.size()-1);
      } else if (!temParents.isEmpty()) {
        current= temParents.get(temParents.size()-1);
        temParents.remove(temParents.size()-1);
      }
    }
    if (d.charAt(i)==')')  if (d.charAt(i-1)!=')') {              
      if (code!="") {
        Node newNode = new Node(code, atrbs, current.loc + '1');
        parent = current;
        current = current.childb;
        if (current==null) {
          current=newNode;
          temParents.add(current);
        }
        nodeList.add(current);
        right=false;
        code="";
        atrbs="";
      } else temParents.add(current);
    }
  }
  Collections.sort(nodeList);
  return (nodeList);
}
ArrayList <Node> setupnodetree(ArrayList <Node> _nodelist, PVector _inpos, PVector _trsize) {                                                         //SETUP TREE : Position, Color, Father's node Child A/B, Father, ChildA true/false, 
  ArrayList <Node> nodelist = _nodelist;                                                                                                              //             Max generations, set leafs, n of leafs, n roots
  PVector inpos = _inpos;
  PVector trsize = _trsize;
  nodelist.get(0).pos = inpos;
  nodelist.get(0).clr = 0.5;
  nodelist.get(0).num=0;
  for (int i=0; i<nodelist.size(); i++) {
    nodelist.get(i).num=i;
    for (int j=0; j<nodelist.size(); j++) if (nodelist.get(i).loc.equals(nodelist.get(j).loc+'0')) {
      nodelist.get(i).pos = new PVector (nodelist.get(j).pos.x-(trsize.x)/(pow(2, nodelist.get(j).gen+1)), nodelist.get(j).pos.y+trsize.y);         //Position
      nodelist.get(j).childa = nodelist.get(i);                                                                                                     //Set fathers node Child A
      nodelist.get(i).father=nodelist.get(j);                                                                                                       //Set father
      nodelist.get(i).childA=true;                                                                                                                  //ChildA = true
      nodelist.get(i).clr=nodelist.get(j).clr-(1/(pow(2, nodelist.get(i).gen+0)));                                                                  //color
    }
    for (int j=0; j<nodelist.size(); j++) if (nodelist.get(i).loc.equals(nodelist.get(j).loc+'1')) {
      nodelist.get(i).pos = new PVector (nodelist.get(j).pos.x+(trsize.x)/(pow(2, nodelist.get(j).gen+1)), nodelist.get(j).pos.y+trsize.y);
      nodelist.get(j).childb = nodelist.get(i);
      nodelist.get(i).father=nodelist.get(j);
      nodelist.get(i).clr=nodelist.get(j).clr+(1/(pow(2, nodelist.get(i).gen+0)));
    }
  }
  int maxgen=0;
  int nroomsc=0;
  int nleafsc=0;
  int nrootsc=0;
  int leafn=0;
  for (int i=0; i<nodelist.size(); i++) if (maxgen<=nodelist.get(i).gen) maxgen = nodelist.get(i).gen;                                                                     //Max generations
  for (int i=0; i<nodelist.size(); i++) nodelist.get(i).ngen = maxgen;                                                                                                   
  for (int i=0; i<nodelist.size(); i++) if (nodelist.get(i).childa==null&&nodelist.get(i).childb==null) if (!nodelist.get(i).code.equals("Zz")) nodelist.get(i).room=true; //Set leafs

  for (int i=0; i<nodelist.size(); i++) if (nodelist.get(i).childa==null&&nodelist.get(i).childb==null) {
    nodelist.get(i).leaf=true;
    nodelist.get(i).leafnum = leafn;
    leafn++;
  }
  for (int i=0; i<nodelist.size(); i++) if (nodelist.get(i).room) nroomsc++;
  for (int i=0; i<nodelist.size(); i++) nodelist.get(i).nrooms = nroomsc;                                                                                               //N of Leafs
  for (int i=0; i<nodelist.size(); i++) if (nodelist.get(i).leaf) nleafsc++;
  for (int i=0; i<nodelist.size(); i++) nodelist.get(i).nleafs = nleafsc;

  for (int i=0; i<nodelist.size(); i++) if (!nodelist.get(i).leaf) nrootsc++;                                                                                              //n Roots
  for (int i=0; i<nodelist.size(); i++) nodelist.get(i).nroots = nrootsc;                                                                 

  for (int i=0; i<nodelist.size(); i++) for (int j=0; j<nodelist.get(i).atri.size(); j++) nodelist.get(i).atri.get(j).pos = new PVector (nodelist.get(i).pos.x+(j*nodelist.get(i).atrsize)-nodelist.get(i).atrsize, nodelist.get(i).pos.y+nodelist.get(i).atrsize);    
  for (int i=0; i<nodelist.size(); i++) if (nodelist.get(i).room) if (nodelist.get(i).atri.size()>1) nodelist.get(i).atri.get(0).max = 2;
  for (int i=0; i<nodelist.size(); i++) if (nodelist.get(i).room) if (nodelist.get(i).atri.size()>1) nodelist.get(i).atri.get(1).step = 1;
  for (int i=0; i<nodelist.size(); i++) if (nodelist.get(i).room) if (nodelist.get(i).atri.size()>1) nodelist.get(i).atri.get(1).max = 7;
  return nodelist;
}
ArrayList<Node> setupnodehouse(ArrayList <Node> _nodelist, PVector _houseinsize) {
  ArrayList <Node> nodelist = _nodelist;
  PVector houseinsize = _houseinsize;
  nodelist.get(0).gpos=new PVector (0, 0);    
  nodelist.get(0).gsize=houseinsize;  
  nodelist.get(0).tpos=new PVector (0, 0);    
  nodelist.get(0).tsize=new PVector (5, 5);  

  for (int i=1; i<nodelist.size(); i++) {      //CALCULATE POSITION AND SIZE OF EACH NODE

    PVector nposA, nposB, nsizeA, nsizeB, sizeAtr, sizeLeft;
    PVector pos = nodelist.get(i).father.gpos;
    PVector size = nodelist.get(i).father.gsize;
    float atr1 = nodelist.get(i).father.atri.get(0).value;
    float atr2 = nodelist.get(i).father.atri.get(1).value;
    float atr3 = nodelist.get(i).father.atri.get(2).value;
    nposA = nposB = nsizeA = nsizeB = sizeAtr = sizeLeft = new PVector();

    if (int(atr3)==0) sizeAtr=PVector.mult(size, atr2);
    if (int(atr3)==0) sizeLeft=PVector.mult(size, 1-atr2);
    if (int(atr3)==1) sizeAtr=new PVector (atr2, atr2);
    if (int(atr3)==1) sizeLeft=new PVector (size.x-(atr2), size.y-(atr2));
    if (int(atr3)==2) sizeAtr=new PVector (size.x-(atr2), size.y-(atr2));
    if (int(atr3)==2) sizeLeft=new PVector (atr2, atr2);

    //nodelist.get(i).gpos = new PVector ();
    if (nodelist.get(i).father.gpos!=null&&nodelist.get(i).father.gsize!=null) {
      if (atr1==0||atr1==1) nposA = new PVector (pos.x, pos.y); 
      if (atr1==0) nposB = new PVector (pos.x+sizeAtr.x, pos.y);        
      if (atr1==0) nsizeA = new PVector (sizeAtr.x, size.y);
      if (atr1==0) nsizeB = new PVector (sizeLeft.x, size.y);               
      if (atr1==1) nposB = new PVector(pos.x, pos.y+sizeAtr.y);
      if (atr1==1) nsizeA = new PVector(size.x, sizeAtr.y); 
      if (atr1==1) nsizeB = new PVector(size.x, sizeLeft.y);
      if (atr1==2||atr1==3) nposB = new PVector (pos.x, pos.y); 
      if (atr1==2) nposA = new PVector (pos.x+sizeAtr.x, pos.y); 
      if (atr1==2) nsizeB= new PVector(sizeAtr.x, size.y);
      if (atr1==2) nsizeA= new PVector(sizeLeft.x, size.y);
      if (atr1==3) nposA = new PVector(pos.x, pos.y+sizeAtr.y);
      if (atr1==3) nsizeB= new PVector(size.x, sizeAtr.y);
      if (atr1==3) nsizeA= new PVector(size.x, sizeLeft.y);
      if (nodelist.get(i).childA) nodelist.get(i).gpos = nposA;
      if (nodelist.get(i).childA) nodelist.get(i).gsize = nsizeA;
      if (!nodelist.get(i).childA) nodelist.get(i).gpos = nposB;
      if (!nodelist.get(i).childA) nodelist.get(i).gsize = nsizeB;
    }       
    PVector tsize =  nodelist.get(i).father.tsize ;                                                                 //TOPOLOGICAL SUBDIVISIONS
    PVector tsizem = PVector.mult(nodelist.get(i).father.tsize, .5);
    PVector pos0 =  nodelist.get(i).father.tpos;
    PVector posx =  new PVector (pos0.x+tsizem.x, pos0.y);
    PVector posy = new PVector (pos0.x, pos0.y+tsizem.y);
    float    atr = nodelist.get(i).father.atri.get(0).value;

    if (nodelist.get(i).childA) {
      if (atr==0||atr==1) nodelist.get(i).tpos =  pos0;  
      if (atr==2)         nodelist.get(i).tpos =  posx;
      if (atr==3)         nodelist.get(i).tpos =  posy;
    }
    if (!nodelist.get(i).childA) {     
      if (atr==0) nodelist.get(i).tpos =  posx;
      if (atr==1) nodelist.get(i).tpos =  posy;
      if (atr==2||atr==3) nodelist.get(i).tpos =  pos0;
    }
    if (atr==0||atr==2) nodelist.get(i).tsize=  new PVector(tsizem.x, tsize.y);   
    if (atr==1||atr==3) nodelist.get(i).tsize=  new PVector(tsize.x, tsizem.y);

    for (int j=0; j<nodelist.size(); j++) if (nodelist.get(i).loc.equals(nodelist.get(j).loc+'0')) nodelist.get(i).father.gpos=nodelist.get(j).gpos;
    for (int j=0; j<nodelist.size(); j++) if (nodelist.get(i).loc.equals(nodelist.get(j).loc+'0')) nodelist.get(i).father.gsize=nodelist.get(j).gsize;
    for (int j=0; j<nodelist.size(); j++) if (nodelist.get(i).loc.equals(nodelist.get(j).loc+'1')) nodelist.get(i).father.gpos=nodelist.get(j).gpos;
    for (int j=0; j<nodelist.size(); j++) if (nodelist.get(i).loc.equals(nodelist.get(j).loc+'1')) nodelist.get(i).father.gsize=nodelist.get(j).gsize;

    for (int j=0; j<nodelist.size(); j++) if (nodelist.get(i).loc.equals(nodelist.get(j).loc+'0')) nodelist.get(i).father.tpos=nodelist.get(j).tpos;
    for (int j=0; j<nodelist.size(); j++) if (nodelist.get(i).loc.equals(nodelist.get(j).loc+'0')) nodelist.get(i).father.tsize=nodelist.get(j).tsize;
    for (int j=0; j<nodelist.size(); j++) if (nodelist.get(i).loc.equals(nodelist.get(j).loc+'1')) nodelist.get(i).father.tpos=nodelist.get(j).tpos;
    for (int j=0; j<nodelist.size(); j++) if (nodelist.get(i).loc.equals(nodelist.get(j).loc+'1')) nodelist.get(i).father.tsize=nodelist.get(j).tsize;
  }
  for (int i=0; i<nodelist.size(); i++) if (nodelist.get(i).room) {                                                                //CALCULATE ADJACENTS
    nodelist.get(i).adjacent= new ArrayList<Node> ();                                                                                
    for (int j=0; j<nodelist.size(); j++) if (nodelist.get(j).room) {
      PVector pos1=   nodelist.get(i).gpos;
      PVector pos2=   nodelist.get(j).gpos;
      PVector size1 = nodelist.get(i).gsize; 
      PVector size2 = nodelist.get(j).gsize;
      if (pos1.x+size1.x==pos2.x&&pos2.y>pos1.y-size2.y&&pos2.y<pos1.y+size1.y) nodelist.get(i).adjacent.add(nodelist.get(j));
      if (pos2.x+size2.x==pos1.x&&pos1.y>pos2.y-size1.y&&pos1.y<pos2.y+size2.y) nodelist.get(i).adjacent.add(nodelist.get(j));
      if (pos1.y+size1.y==pos2.y&&pos2.x>pos1.x-size2.x&&pos2.x<pos1.x+size1.x) nodelist.get(i).adjacent.add(nodelist.get(j));
      if (pos2.y+size2.y==pos1.y&&pos1.x>pos2.x-size1.x&&pos1.x<pos2.x+size2.x) nodelist.get(i).adjacent.add(nodelist.get(j));
    }
  }


  for (int i=0; i<nodelist.size(); i++) if (nodelist.get(i).room) {                                                                //CALCULATE TOPological ADJACENTS
    nodelist.get(i).tadjacent= new ArrayList<Node> ();                                                                                
    for (int j=0; j<nodelist.size(); j++) if (nodelist.get(j).room) {
      PVector pos1=   nodelist.get(i).tpos;
      PVector pos2=   nodelist.get(j).tpos;
      PVector size1 = nodelist.get(i).tsize; 
      PVector size2 = nodelist.get(j).tsize;
      if (pos1.x+size1.x==pos2.x&&pos2.y>pos1.y-size2.y&&pos2.y<pos1.y+size1.y) nodelist.get(i).tadjacent.add(nodelist.get(j));
      if (pos2.x+size2.x==pos1.x&&pos1.y>pos2.y-size1.y&&pos1.y<pos2.y+size2.y) nodelist.get(i).tadjacent.add(nodelist.get(j));
      if (pos1.y+size1.y==pos2.y&&pos2.x>pos1.x-size2.x&&pos2.x<pos1.x+size1.x) nodelist.get(i).tadjacent.add(nodelist.get(j));
      if (pos2.y+size2.y==pos1.y&&pos1.x>pos2.x-size1.x&&pos1.x<pos2.x+size2.x) nodelist.get(i).tadjacent.add(nodelist.get(j));

      //if (pos1.x+size1.x==pos2.x) nodelist.get(i).tadjacent.add(nodelist.get(j));
      //if (pos2.x+size2.x==pos1.x) nodelist.get(i).tadjacent.add(nodelist.get(j));
      //if (pos1.y+size1.y==pos2.y) nodelist.get(i).tadjacent.add(nodelist.get(j));
      //if (pos2.y+size2.y==pos1.y) nodelist.get(i).tadjacent.add(nodelist.get(j));
    }
  }

  for (int i=0; i<nodelist.size(); i++) if (nodelist.get(i).room) {                                                                   //CALCULATE QUALITIES
    float shortm, longm; 
    if (nodelist.get(i).gsize.x<nodelist.get(i).gsize.y) shortm = nodelist.get(i).gsize.x; 
    else shortm = nodelist.get(i).gsize.y;  
    if (nodelist.get(i).gsize.x<nodelist.get(i).gsize.y) longm = nodelist.get(i).gsize.y; 
    else longm = nodelist.get(i).gsize.x;
    nodelist.get(i).qualities.set(0, round(shortm*100)/100.0);
    nodelist.get(i).qualities.set(1, round(longm*100)/100.0);
    nodelist.get(i).qualities.set(2, round(shortm*longm*100)/100.0);
    nodelist.get(i).qualities.set(3, round((shortm/longm)*100)/100.0);
  }
  for (int i=0; i<nodelist.size(); i++) if (nodelist.get(i).room) {                                                                     //CALCULATE FITNESS FOR EVERY ROOM
    float fitn=0;
    if (nodelist.get(i).idealqualities.size()!=0) fitn = fitn+(sq(nodelist.get(i).qualities.get(0)-nodelist.get(i).idealqualities.get(0)) * nodelist.get(i).qualitiesweight.get(0));         //short * squared * weight
    if (nodelist.get(i).idealqualities.size()!=0) fitn = fitn+(sq(nodelist.get(i).qualities.get(1)-nodelist.get(i).idealqualities.get(1))* nodelist.get(i).qualitiesweight.get(1));          //long * squared  * weight
    if (nodelist.get(i).idealqualities.size()!=0) fitn = fitn+(abs(nodelist.get(i).qualities.get(2)-nodelist.get(i).idealqualities.get(2))* nodelist.get(i).qualitiesweight.get(2));         //area  * weight
    if (nodelist.get(i).idealqualities.size()!=0) fitn = fitn+(10*abs(nodelist.get(i).qualities.get(3)-nodelist.get(i).idealqualities.get(3))* nodelist.get(i).qualitiesweight.get(3));      //prop *10          * weigth                                                                                                        //ADJECENCY FITNESS
    
    ArrayList <String> adjS = new ArrayList <String> ();                                                                              //calculate fitness adjacent for every non adjacent that has to be add 5   * weight
    for (int j=0; j<nodelist.get(i).adjacent.size(); j++)  adjS.add(j, nodelist.get(i).adjacent.get(j).code);
    nodelist.get(i).fitadj=0;
    if (nodelist.get(i).idealadjacent!=null&&nodelist.get(i).idealadjw!=null) for (int m=0; m<nodelist.get(i).idealadjacent.size(); m++) if (!adjS.contains(nodelist.get(i).idealadjacent.get(m))) nodelist.get(i).fitadj = nodelist.get(i).fitadj+(5*float(nodelist.get(i).idealadjw.get(m)));    //Adj 5 per adj
    fitn =fitn + nodelist.get(i).fitadj;  
    nodelist.get(i).fit = round(fitn*100)/100.0;   
  } 
  float tfit=0;                                                                                                                         //ADD ALL ROOMS FITTNESS ADD TO EACH ROOM
  for (int i=0; i<nodelist.size(); i++) tfit = tfit+nodelist.get(i).fit;
  for (int i=0; i<nodelist.size(); i++) nodelist.get(i).totalfit = tfit;
  return nodelist;
}
String treestr(String _plaintext) {
  String [] stext=split(_plaintext, ",");
  int numleafs=stext.length;
  String textout="";
  for (int i=0; i<numleafs-1; i++) textout=textout+"x (";
  textout=textout+stext[0];
  for (int i=1; i<numleafs; i++) textout=textout+","+stext[i]+")";
  return textout;
}
BigInteger fact(int _num) { 
  BigInteger num = new BigInteger(""+_num);
  if (num.compareTo(new BigInteger("1")) < 1) return new BigInteger("1");      
  else return num.multiply(fact(num.add(new BigInteger("-1")).intValue()));
}
BigInteger  catalan(int n) {
  return (fact(2*n)).divide((fact(n+1).multiply(fact(n))));
}
int  catalanint(int n) {
  BigInteger num = (fact(2*n)).divide((fact(n+1).multiply(fact(n))));
  return num.intValue();
}
int factint(int _num) {
  if (_num<=1) return 1;
  else return _num*factint(_num-1);
}